"""
This crap was mostly generated by Claude
"""

from dataclasses import dataclass
from decimal import Decimal
from typing import Dict, Optional

from nautilus_trader.core.message import Event
from nautilus_trader.model import QuoteTick
from nautilus_trader.model.enums import OrderSide, TimeInForce
from nautilus_trader.model.identifiers import InstrumentId, Symbol, Venue, ClientId
from nautilus_trader.model.objects import Quantity
from nautilus_trader.trading.config import StrategyConfig
from nautilus_trader.trading.strategy import Strategy

from config import SYMBOLS, HYPERLIQUID_VENUE, BINANCE_VENUE


@dataclass
class PriceData:
    """Container for price data from different venues."""
    instrument: str
    venue: str
    bid: Optional[float] = None
    ask: Optional[float] = None
    timestamp: Optional[int] = None


@dataclass
class ArbitrageOpportunity:
    """Container for arbitrage opportunity data."""
    instrument: str
    buy_venue: str
    sell_venue: str
    buy_price: float
    sell_price: float
    profit_pct: float
    max_quantity: float


class ArbitrageStrategyConfig(StrategyConfig, frozen=True):
    """Configuration for ArbitrageStrategy."""
    profit_threshold: float = 0.002  # Minimum profit threshold (0.2%)
    max_position_size: float = 1000.0
    risk_check_interval: float = 5.0


class ArbitrageStrategy(Strategy):
    """
    Arbitrage strategy that monitors price differences between Hyperliquid and Binance.

    The strategy:
    1. Receives price data from both venues via custom data clients
    2. Calculates arbitrage opportunities when price differences exceed threshold
    3. Executes simultaneous buy/sell orders on different venues
    4. Manages risk and position sizes
    """

    def __init__(self, config: ArbitrageStrategyConfig) -> None:
        super().__init__(config=config)

        # Strategy configuration
        self.profit_threshold = config.profit_threshold
        self.max_position_size = config.max_position_size
        self.instruments = SYMBOLS
        self.risk_check_interval = config.risk_check_interval

        # Price data storage
        self.price_data: Dict[str, Dict[str, PriceData]] = {}
        for instrument in self.instruments:
            self.price_data[instrument] = {
                "HYPERLIQUID": PriceData(instrument, "HYPERLIQUID"),
                "BINANCE": PriceData(instrument, "BINANCE")
            }

        # Risk management
        self.active_positions: Dict[str, Dict[str, Decimal]] = {}
        self.last_risk_check = 0

        # Performance tracking
        self.opportunities_found = 0
        self.trades_executed = 0
        self.total_profit = Decimal("0")

    def on_start(self) -> None:
        """Called when the strategy is started."""
        self.log.info("ArbitrageStrategy started")
        self.log.info(f"Monitoring instruments: {self.instruments}")
        self.log.info(f"Profit threshold: {self.profit_threshold:.2%}")
        self.log.info(f"Max position size: {self.max_position_size}")

        # Initialize active positions tracking
        for instrument in self.instruments:
            self.active_positions[instrument] = {
                "HYPERLIQUID": Decimal("0"),
                "BINANCE": Decimal("0")
            }
            for venue in [HYPERLIQUID_VENUE, BINANCE_VENUE]:
                instrument_id = InstrumentId(symbol=Symbol(instrument), venue=Venue(venue))
                self.log.info(f"Subscribing to {instrument_id}")
                self.subscribe_quote_ticks(instrument_id, ClientId("JUST-PPE-STRATEGY"))

    def on_stop(self) -> None:
        """Called when the strategy is stopped."""
        self.log.info("ArbitrageStrategy stopped")
        self.log.info(f"Total opportunities found: {self.opportunities_found}")
        self.log.info(f"Total trades executed: {self.trades_executed}")
        self.log.info(f"Total profit: {self.total_profit}")

    def handle_quote_tick(self, tick: QuoteTick) -> None:
        """Handle incoming price data from custom data clients."""
        self.log.info(f"handle_quote_tick {tick}")
        try:
            self._update_price_data(tick)
            self._check_arbitrage_opportunities()

        except Exception as e:
            self.log.error(f"Error processing data: {e}")

    def _update_price_data(self, price_info: QuoteTick) -> None:
        """Update internal price data storage."""
        instrument = price_info.instrument_id.symbol.value
        venue = price_info.instrument_id.venue.value

        if instrument not in self.price_data or venue not in self.price_data[instrument]:
            return

        price_data = self.price_data[instrument][venue]
        price_data.bid = price_info.bid_price
        price_data.ask = price_info.ask_price
        price_data.timestamp = price_info.ts_event

        self.log.debug(f"Updated {venue} {instrument}: bid={price_data.bid}, ask={price_data.ask}")

    def _check_arbitrage_opportunities(self) -> None:
        """Check for arbitrage opportunities across all instruments."""
        current_time = self.clock.timestamp_ns()

        # Perform risk check periodically
        if (current_time - self.last_risk_check) > (self.risk_check_interval * 1_000_000_000):
            self._perform_risk_check()
            self.last_risk_check = current_time

        for instrument in self.instruments:
            opportunity = self._calculate_arbitrage_opportunity(instrument)
            if opportunity and opportunity.profit_pct >= self.profit_threshold:
                self.opportunities_found += 1
                self.log.info(f"Arbitrage opportunity found: {opportunity}")
                self._execute_arbitrage_trade(opportunity)

    def _calculate_arbitrage_opportunity(self, instrument: str) -> Optional[ArbitrageOpportunity]:
        """Calculate arbitrage opportunity for a specific instrument."""
        hyperliquid_data = self.price_data[instrument]["HYPERLIQUID"]
        binance_data = self.price_data[instrument]["BINANCE"]

        # Check if we have valid price data from both venues
        if not all([
            hyperliquid_data.bid, hyperliquid_data.ask,
            binance_data.bid, binance_data.ask
        ]):
            return None

        # Check data freshness (within last 10 seconds)
        current_time = self.clock.timestamp_ns() // 1_000_000_000  # Convert to seconds
        if hyperliquid_data.timestamp and (current_time - hyperliquid_data.timestamp) > 10:
            return None
        if binance_data.timestamp and (current_time - binance_data.timestamp) > 10:
            return None

        # Calculate opportunities in both directions
        opportunities = []

        # Buy from Hyperliquid, sell to Binance
        if hyperliquid_data.ask and binance_data.bid:
            profit_pct = (binance_data.bid - hyperliquid_data.ask) / hyperliquid_data.ask
            if profit_pct > 0:
                opportunities.append(ArbitrageOpportunity(
                    instrument=instrument,
                    buy_venue="HYPERLIQUID",
                    sell_venue="BINANCE",
                    buy_price=hyperliquid_data.ask,
                    sell_price=binance_data.bid,
                    profit_pct=profit_pct,
                    max_quantity=min(1000.0, self.max_position_size)  # Simplified
                ))

        # Buy from Binance, sell to Hyperliquid
        if binance_data.ask and hyperliquid_data.bid:
            profit_pct = (hyperliquid_data.bid - binance_data.ask) / binance_data.ask
            if profit_pct > 0:
                opportunities.append(ArbitrageOpportunity(
                    instrument=instrument,
                    buy_venue="BINANCE",
                    sell_venue="HYPERLIQUID",
                    buy_price=binance_data.ask,
                    sell_price=hyperliquid_data.bid,
                    profit_pct=profit_pct,
                    max_quantity=min(1000.0, self.max_position_size)  # Simplified
                ))

        # Return the most profitable opportunity
        return max(opportunities, key=lambda x: x.profit_pct) if opportunities else None

    def _execute_arbitrage_trade(self, opportunity: ArbitrageOpportunity) -> None:
        """Execute arbitrage trade."""
        try:
            # Check if we can execute this trade (risk management)
            if not self._can_execute_trade(opportunity):
                self.log.warning(f"Trade blocked by risk management: {opportunity.instrument}")
                return

            # Calculate trade quantity
            trade_quantity = self._calculate_trade_quantity(opportunity)
            if trade_quantity <= 0:
                self.log.warning("Trade quantity too small, skipping")
                return

            self.log.info(f"Executing arbitrage trade: {opportunity.instrument}")
            self.log.info(f"Buy {trade_quantity} on {opportunity.buy_venue} at {opportunity.buy_price}")
            self.log.info(f"Sell {trade_quantity} on {opportunity.sell_venue} at {opportunity.sell_price}")

            # Create instrument IDs
            buy_instrument_id = InstrumentId.from_str(f"{opportunity.instrument}.{opportunity.buy_venue}")
            sell_instrument_id = InstrumentId.from_str(f"{opportunity.instrument}.{opportunity.sell_venue}")

            # Create buy order
            buy_order = self.order_factory.market(
                instrument_id=buy_instrument_id,
                order_side=OrderSide.BUY,
                quantity=Quantity.from_str(str(trade_quantity)),
                time_in_force=TimeInForce.IOC,
            )

            # Create sell order
            sell_order = self.order_factory.market(
                instrument_id=sell_instrument_id,
                order_side=OrderSide.SELL,
                quantity=Quantity.from_str(str(trade_quantity)),
                time_in_force=TimeInForce.IOC,
            )

            # Submit orders simultaneously
            self.submit_order(buy_order)
            self.submit_order(sell_order)

            # Update position tracking
            self.active_positions[opportunity.instrument][opportunity.buy_venue] += Decimal(str(trade_quantity))
            self.active_positions[opportunity.instrument][opportunity.sell_venue] -= Decimal(str(trade_quantity))

            # Track performance
            self.trades_executed += 2  # Two orders
            expected_profit = Decimal(str(trade_quantity * opportunity.buy_price * float(opportunity.profit_pct)))
            self.total_profit += expected_profit

            self.log.info(f"Trade executed successfully. Expected profit: {expected_profit}")

        except Exception as e:
            self.log.error(f"Error executing arbitrage trade: {e}")

    def _can_execute_trade(self, opportunity: ArbitrageOpportunity) -> bool:
        """Check if trade can be executed based on risk management rules."""
        # Check position limits
        buy_venue_position = abs(self.active_positions[opportunity.instrument][opportunity.buy_venue])
        sell_venue_position = abs(self.active_positions[opportunity.instrument][opportunity.sell_venue])

        # if buy_venue_position >= self.max_position_size or sell_venue_position >= self.max_position_size:
        #     return False

        return True

    def _calculate_trade_quantity(self, opportunity: ArbitrageOpportunity) -> float:
        """Calculate optimal trade quantity."""
        # Simplified quantity calculation
        # In practice, this would consider available balance, position limits, etc.
        max_quantity = min(
            opportunity.max_quantity,
            self.max_position_size,
            100.0  # Conservative max per trade
        )

        return max_quantity

    def _perform_risk_check(self) -> None:
        """Perform periodic risk checks."""
        self.log.debug("Performing risk check...")

        # Log current positions
        for instrument in self.instruments:
            hyperliquid_pos = self.active_positions[instrument]["HYPERLIQUID"]
            binance_pos = self.active_positions[instrument]["BINANCE"]
            if hyperliquid_pos != 0 or binance_pos != 0:
                self.log.info(f"{instrument} positions - HYPERLIQUID: {hyperliquid_pos}, BINANCE: {binance_pos}")

    def on_event(self, event: Event) -> None:
        """Handle trading events (fills, rejections, etc.)."""
        if hasattr(event, 'venue_order_id'):
            self.log.info(f"Order event: {type(event).__name__} - {event}")
